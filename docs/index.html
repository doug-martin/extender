<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>extender</title>
    <link rel="stylesheet" href="./assets/css/bootstrap.css">
    <link rel="stylesheet" href="./assets/css/prettify.css">
    <style type="text/css">
        

/*.subnav-inner {*/
    /*width: 100%;*/
    /*height: 36px;*/
    /*background-color: #EEE;*/
    /*background-repeat: repeat-x;*/
    /*background-image: -moz-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -webkit-gradient(linear, left top, left bottom, color-stop(0%, whiteSmoke), color-stop(100%, #EEE));*/
    /*background-image: -webkit-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -ms-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*background-image: -o-linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(startColorstr = '#f5f5f5', endColorstr = '#eeeeee', GradientType = 0);*/
    /*background-image: linear-gradient(top, whiteSmoke 0%, #EEE 100%);*/
    /*-webkit-border-radius: 4px;*/
    /*-moz-border-radius: 4px;*/
    /*border-radius: 4px;*/
/*}*/

/*.subnav .nav > li > a:hover {*/
    /*color: black !important;*/
/*}*/

/*.subnav .nav li.dropdown .dropdown-toggle .caret,*/
/*.subnav .nav li.dropdown.open .caret {*/
    /*border-top-color: #999 !important;*/
    /*border-bottom-color: #999 !important;*/
/*}*/

/*.subnav-fixed {*/
    /*position: fixed;*/
    /*width : 90%;*/
    /*margin-right: auto;*/
    /*margin-left: auto;*/
    /*top: 40px;*/
    /*left: 0;*/
    /*right: 0;*/
    /*z-index: 1020;*/
    /*border-color: #D5D5D5;*/
    /*border-width: 0 0 1px;*/
    /*-webkit-border-radius: 0;*/
    /*-moz-border-radius: 0;*/
    /*border-radius: 0;*/
    /*-webkit-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*-moz-box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*box-shadow: inset 0 1px 0 #fff, 0 1px 5px rgba(0,0,0,.1);*/
    /*filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);*/
/*}*/

/*.navbar .nav  .dropdown-menu {*/
    /*max-height: 500px;*/
    /*overflow: auto;*/
/*}â€‹*/

    </style>
    <style type="text/css">
        body {
            padding: 90px;
        }

        .subnav{
            margin-top: 40px;
            margin-right: auto;
            margin-left: auto;
            z-index: 1000;
        }

        @media (max-width:979px) {
            .subnav{
                margin-top: auto;
            }
        }
    </style>
    <link rel="stylesheet" href="./assets/css/bootstrap-responsive.css">
    <script type="text/javascript">
        var init = (function () {
            "use strict";

            var processScroll = (function () {
                var curr = null, prev = null;
                return function (nav) {
                    var $win = $(window);
                    $('.subnav').each(function () {
                        var nav = $(this);
                        var navTop = $win.width() < 980 ? 0 : nav.offset().top - 40;

                        var scrollTop = $win.scrollTop();
                        if (scrollTop >= navTop && curr != nav) {
                            if(curr){
                                curr.removeClass('subnav-fixed')
                                prev = curr;
                            }
                            curr = nav;
                            curr.addClass('subnav-fixed')
                        } else if (curr == nav && scrollTop <= navTop) {
                            curr.removeClass('subnav-fixed');
                            prev.addClass('subnav-fixed');
                            curr = prev;
                        }else{
                            nav.removeClass('subnav-fixed');
                        }
                    });
                };
            })();

            return function () {
                window.prettyPrint && prettyPrint();
                $(".collapse").collapse();
                var $window = $(window);
                //$(".subnav").affix ();
                // fix sub nav on scroll
//                processScroll();
//                $(window).on('scroll', processScroll)
            }
        })();
    </script>
</head>
<body onload="init()">
<div class="navbar navbar-fixed-top navbar-inverse">
    <div class="navbar-inner">
        <div class="container">
            <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"> </span>
            </a>
            
            <a href="./index.html" class="brand">extender</a>
            
            <div class="nav-collapse">
                <ul class="nav">
                    

                        
                    
                </ul>
                
                <ul class="nav pull-right">

                    <li class="divider-vertical"></li>
                    <li><a href="http://github.com/doug-martin/extender" target="#github" class="pull-right">github</a></li>
                </ul>
                
            </div>
        </div>
    </div>
</div>



<div class="container-fluid">
    <a name="top"></a>
    <div class="container">




  <p><a href="http://travis-ci.org/doug-martin/extender"><img src="https://secure.travis-ci.org/doug-martin/extender.png" alt="build status"></a>
</p>
<h1>Extender</h1>
<p><code>extender</code> is a library that helps in making chainable APIs, by creating a function that accepts different values and returns an object decorated with functions based on the type.

</p>
<h2>Why Is Extender Different?</h2>
<p>Extender is different than normal chaining because is does more than return <code>this</code>. It decorates your values in a type safe manner.

</p>
<p>For example if you return an array from a string based method then the returned value will be decorated with array methods and not the string methods. This allow you as the developer to focus on your API and not worrying about how to properly build and connect your API.


</p>
<h2>Installation</h2>
<pre class='prettyprint linenums lang-js'><code>npm install extender</code></pre>
<p>Or <a href="https://raw.github.com/doug-martin/extender/master/extender.js">download the source</a> (<a href="https://raw.github.com/doug-martin/extender/master/extender-min.js">minified</a>)

</p>
<p><strong>Note</strong> <code>extender</code> depends on <a href="http://doug-martin.github.com/declare.js/"><code>declare.js</code></a>.

</p>
<h3>Requirejs</h3>
<p>To use with requirejs place the <code>extend</code> source in the root scripts directory

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
define([&quot;extender&quot;], function(extender){
});</code></pre>
<h2>Usage</h2>
<p><strong><code>extender.define(tester, decorations)</code></strong>

</p>
<p>To create your own extender call the <code>extender.define</code> function.

</p>
<p>This function accepts an optional tester which is used to determine a value should be decorated with the specified <code>decorations</code>

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">function isString(obj) {
    return !isUndefinedOrNull(obj) &amp;&amp; (typeof obj === &quot;string&quot; || obj instanceof String);
}


var myExtender = extender.define(isString, {
    multiply: function (str, times) {
        var ret = str;
        for (var i = 1; i &lt; times; i++) {
            ret += str;
        }
        return ret;
    },
    toArray: function (str, delim) {
        delim = delim || &quot;&quot;;
        return str.split(delim);
    }
});

myExtender(&quot;hello&quot;).multiply(2).value(); //hellohello</code></pre>
<p>If you do not specify a tester function and just pass in an object of <code>functions</code> then all values passed in will be decorated with methods.

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">
function isUndefined(obj) {
    var undef;
    return obj === undef;
}

function isUndefinedOrNull(obj) {
var undef;
    return obj === undef || obj === null;
}

function isArray(obj) {
    return Object.prototype.toString.call(obj) === &quot;[object Array]&quot;;
}

function isBoolean(obj) {
    var undef, type = typeof obj;
    return !isUndefinedOrNull(obj) &amp;&amp; type === &quot;boolean&quot; || type === &quot;Boolean&quot;;
}

function isString(obj) {
    return !isUndefinedOrNull(obj) &amp;&amp; (typeof obj === &quot;string&quot; || obj instanceof String);
}

var myExtender = extender.define({
isUndefined : isUndefined,
isUndefinedOrNull : isUndefinedOrNull,
isArray : isArray,
isBoolean : isBoolean,
isString : isString
});</code></pre>
<p>To use

</p>
<pre class='prettyprint linenums lang-js'><code>var undef;
myExtender(&quot;hello&quot;).isUndefined().value(); //false
myExtender(undef).isUndefined().value(); //true</code></pre>
<p>You can also chain extenders so that they accept multiple types and decorates accordingly.

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">myExtender
    .define(isArray, {
    pluck: function (arr, m) {
        var ret = [];
        for (var i = 0, l = arr.length; i &lt; l; i++) {
            ret.push(arr[i][m]);
        }
        return ret;
    }
})
    .define(isBoolean, {
    invert: function (val) {
        return !val;
    }
});

myExtender([{a: &quot;a&quot;},{a: &quot;b&quot;},{a: &quot;c&quot;}]).pluck(&quot;a&quot;).value(); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
myExtender(&quot;I love javascript!&quot;).toArray(/\s+/).pluck(&quot;0&quot;); //[&quot;I&quot;, &quot;l&quot;, &quot;j&quot;]</code></pre>
<p>Notice that we reuse the same extender as defined above.

</p>
<p><strong>Return Values</strong>

</p>
<p>When creating an extender if you return a value from one of the decoration functions then that value will also be decorated. If you do not return any values then the extender will be returned.

</p>
<p><strong>Default decoration methods</strong>

</p>
<p>By default every value passed into an extender is decorated with the following methods.

</p>
<ul>
<li><code>value</code> : The value this extender represents.</li>
<li><code>eq(otherValue)</code> : Tests strict equality of the currently represented value to the <code>otherValue</code></li>
<li><code>neq(oterValue)</code> : Tests strict inequality of the currently represented value.</li>
<li><code>print</code> : logs the current value to the console.</li>
</ul>
<p><strong>Extender initialization</strong>

</p>
<p>When creating an extender you can also specify a constructor which will be invoked with the current value.

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">myExtender.define(isString, {
constructor : function(val){
    //set our value to the string trimmed
    this._value = val.trimRight().trimLeft();
}
});</code></pre>
<p><strong><code>noWrap</code></strong>

</p>
<p><code>extender</code> also allows you to specify methods that should not have the value wrapped providing a cleaner exit function other than <code>value()</code>.

</p>
<p>For example suppose you have an API that allows you to build a validator, rather than forcing the user to invoke the <code>value</code> method you could add a method called <code>validator</code> which makes more syntactic sense.

</p>
<pre class='prettyprint linenums lang-js'><code>
var myValidator = extender.define({
    //chainable validation methods
    //...
    //end chainable validation methods

    noWrap : {
        validator : function(){
            //return your validator
        }
    }
});

myValidator().isNotNull().isEmailAddress().validator(); //now you dont need to call .value()</code></pre>
<p><strong><code>extender.extend(extendr)</code></strong>

</p>
<p>You may also compose extenders through the use of <code>extender.extend(extender)</code>, which will return an entirely new extender that is the composition of extenders.

</p>
<p>Suppose you have the following two extenders.

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var myExtender = extender
       .define({
           isFunction: is.function,
           isNumber: is.number,
           isString: is.string,
           isDate: is.date,
           isArray: is.array,
           isBoolean: is.boolean,
           isUndefined: is.undefined,
           isDefined: is.defined,
           isUndefinedOrNull: is.undefinedOrNull,
           isNull: is.null,
           isArguments: is.arguments,
           isInstanceOf: is.instanceOf,
           isRegExp: is.regExp
       });
var myExtender2 = extender.define(is.array, {
    pluck: function (arr, m) {
        var ret = [];
        for (var i = 0, l = arr.length; i &lt; l; i++) {
            ret.push(arr[i][m]);
        }
        return ret;
    },

    noWrap: {
        pluckPlain: function (arr, m) {
            var ret = [];
            for (var i = 0, l = arr.length; i &lt; l; i++) {
                ret.push(arr[i][m]);
            }
            return ret;
        }
    }
});</code></pre>
<p>And you do not want to alter either of them but instead what to create a third that is the union of the two.


</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var composed = extender.extend(myExtender).extend(myExtender2);</code></pre>
<p>So now you can use the new extender with the joined functionality if <code>myExtender</code> and <code>myExtender2</code>.

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var extended = composed([
     {a: &quot;a&quot;},
     {a: &quot;b&quot;},
     {a: &quot;c&quot;}
]);
extended.isArray().value(); //true
extended.pluck(&quot;a&quot;).value(); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);</code></pre>
<p><strong>Note</strong> <code>myExtender</code> and <code>myExtender2</code> will <strong>NOT</strong> be altered.

</p>
<p><strong><code>extender.expose(methods)</code></strong>

</p>
<p>The <code>expose</code> method allows you to add methods to your extender that are not wrapped or automatically chained by exposing them on the extender directly.

</p>
<pre class='prettyprint linenums lang-js'><code>var isMethods = {
     isFunction: is.function,
     isNumber: is.number,
     isString: is.string,
     isDate: is.date,
     isArray: is.array,
     isBoolean: is.boolean,
     isUndefined: is.undefined,
     isDefined: is.defined,
     isUndefinedOrNull: is.undefinedOrNull,
     isNull: is.null,
     isArguments: is.arguments,
     isInstanceOf: is.instanceOf,
     isRegExp: is.regExp
};

var myExtender = extender.define(isMethods).expose(isMethods);

myExtender.isArray([]); //true
myExtender([]).isArray([]).value(); //true</code></pre>
<p><strong>Using <code>instanceof</code></strong>

</p>
<p>When using extenders you can test if a value is an <code>instanceof</code> of an extender by using the instanceof operator.

</p>
<pre class='prettyprint linenums lang-js'><code class="lang-javascript">var str = myExtender(&quot;hello&quot;);

str instanceof myExtender; //true</code></pre>
<h2>Examples</h2>
<p>To see more examples click <a href="https://github.com/doug-martin/extender/tree/master/examples">here</a></p>


<hr>

Documentation generated using <a href="https://github.com/doug-martin/coddoc">coddoc</a>.


</div>
</div>
<script type="text/javascript" src="./assets/js/jquery.js"></script>
<script type="text/javascript" src="./assets/js/bootstrap.min.js"></script>
<script type="text/javascript" src="./assets/js/prettify.js"></script>

</body>
</html>

